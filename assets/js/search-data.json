{
  
    
        "post0": {
            "title": "Interactive Genetic Algorithm Dashboard from Scratch in Python",
            "content": "What are we doing? . If you want to interact with the final result first, you can play with it on to PyViz examples here: https://genetic-algorithm.pyviz.demo.anaconda.com/GA . How can you maximise the number of components in a laptop, while having size, weight and price constraints? For questions like these, we often want to reach for optimisation algorithms, and one particularly fun one is Genetic Algorithm. . Genetic Algorithm is cool so I created an interactive Genetic Algorithm dashboard with @HoloViews and @Panel_org.Click to set a target and see the little critters evolve to be closest to it. Each time there is a generational update, the plot changes to show their positions. pic.twitter.com/5K9Ehp7wlo . &mdash; Scott Condron (@_ScottCondron) July 18, 2020 . Our example problem . For the sake of a fun visualisation, let&#39;s say the optimisation is &quot;Wherever I click on the plot is the optimimum spot to find&quot;. We&#39;re going to use a population-based approach, Genetic Algorithm, in which there is a population of individuals (each individual representing a possible solution) which evolve across generations. Each solution is just the individual&#39;s x and y coordinates. . What we want to see . We want to see a kind of &quot;evolution simulator&quot; in which we click a spot on the plot and when we begin evolving, each generation moves closer to the place we clicked. . We need a population . &quot;And God said, Let us make man in our image&quot;. First, let&#39;s create a population. . Imports . #collapse-hide import math import numpy as np import pandas as pd import random from holoviews import opts from matplotlib import pyplot as plt import holoviews as hv import panel as pn from holoviews.streams import Stream hv.extension(&#39;matplotlib&#39;, logo=False) . . Create Population . #collapse-show def create_population(population_size, vector_length): return np.random.rand(population_size, vector_length) population_size = 100 vector_length = 2 current_population = create_population(population_size, vector_length) hv.Scatter(current_population) . . Survival of the fittest . We&#39;re going to need to evolve individuals from our population, so we need some way to check which of the population is the fittest. . &#160;Closer (smaller distance) is better . For the sake of this visualisation, we&#39;re going to place a target on the plot and the &quot;fitness&quot; of a individual is how close they are to the target. We&#39;re going to calculate the distance using the euclidean distance metric. . #collapse-show def mean_squared_error(y_true, y_pred): return ((y_true - y_pred)**2).mean(axis=0) target_x, target_y = 0,0 def problem(soln): global target_x #using globals so we can link this to the click event later global target_y return mean_squared_error(soln, [target_x, target_y]) . . Then we need a way to check, who&#39;s our fittest member of our community . #collapse-show def assess_fitness(individual, problem): &quot;Determines the fitness of an individual using the given problem&quot; return problem(individual) def find_current_best(population, problem): &quot;&quot;&quot;Evaluates a given population and returns the fittest individual. This can be sped up to only loop over popuation once, but because this is a tutorial, 3 lines is nicer. &quot;&quot;&quot; fitnesses = [assess_fitness(x, problem) for x in population] best_value = min(fitnesses) # Lowest is best best_index = fitnesses.index(best_value) return population[best_index] . . aaaand Fight! . Now, we&#39;re going to let these potential solutions fight it out and only let a certain few have offspring. For this we will use &quot;Tournament Selection&quot; which is just grabbing a few individuals and having them compete to the death (the fittest survives!). . What&#39;s nice about this is that you can keep a bit of diversity within the population and it&#39;s not just the best that survive, some lucky unfit individuals might be matched up with worse folk, and so they&#39;ll survive. . #collapse-show def tournament_select_with_replacement(population, tournament_size, problem): &quot;Competes a number of challengers and returns the fittest one&quot; challengers_indexes = np.random.choice(population.shape[0], tournament_size, replace=True) challengers = population[challengers_indexes] return find_current_best(challengers, problem) . . Then once we have done this twice, those two individuals can &quot;mate&quot; and have children... to keep the population the same across generations for simplicity, they&#39;ll have two children. We&#39;ll use Two point Crossover), which is just splitting both parents in three parts and swapping the middle part to form two children. . #collapse-show def crossover(parent_a, parent_b): &quot;Performs two point crossover on two parents&quot; l = parent_a.shape[0] c, d = random.randint(0, l), random.randint(0, l) # Flip if c greater than d if (c &gt; d): d, c = c, d if (c == d): d += 1 temp = np.copy(parent_a) child_a = np.concatenate([parent_a[0:c], parent_b[c:d], parent_a[d:]]) child_b = np.concatenate([parent_b[0:c], temp[c:d], parent_b[d:]]) return child_a, child_b . . . Mutate! . For extra variety across generations, we want to introduce a bit of chaos to the system to produce the Marie Curie of each generation (but also probably our least capable individuals too). This helps find new solutions outside our current population&#39;s capability. So for each individual, there&#39;s a chance that their offspring will mutate (determined by mutation_rate). . #collapse-show def mutate(child, mutation_rate, mutation_scale): &quot;May mutate a child using Gaussian convolution&quot; if mutation_rate &gt;= random.uniform(0, 1): size = child.shape[0] mutation_value = np.random.normal(0, mutation_scale, size) child = child + mutation_value return child . . Here&#39;s the entirety of what happens to the population between generations. To recap: a bunch from the current population are selected at random to compete to reproduce. Two parents then produce two children using a mix of the two parents for both children. Finally, each child has a chance that they will mutate. One we&#39;ve created a new population of the same size as the original population, we have completed one &quot;generation&quot;. . #collapse-show def update_population(current_population, problem, should_mutate, mutation_rate, mutation_scale): &quot;&quot;&quot;Performs one generational update of Genetic Algorithm&quot;&quot;&quot; pop_size = len(current_population) next_population = np.empty((pop_size, 2)) tournament_size=2 for i in range(int(pop_size / 2)): parent_a = tournament_select_with_replacement(current_population, tournament_size, problem) parent_b = tournament_select_with_replacement(current_population, tournament_size, problem) child_a, child_b = crossover(parent_a, parent_b) next_population[i] = mutate(child_a, mutation_rate, mutation_scale) if should_mutate else child_a position_child_b = i + (pop_size / 2) next_population[int(position_child_b)] = mutate(child_b, mutation_rate, mutation_scale) if should_mutate else child_b return next_population . . A little class for saving the state of the evolution . #collapse-show class GeneticAlgorithm(object): def __init__(self, population_size, vector_length, problem): self.problem = problem self.current_population = create_population(population_size, vector_length) self.current_best = find_current_best(self.current_population, self.problem) def next_generation(self, mrate, mscale, should_mutate): self.current_population = update_population(self.current_population, self.problem, should_mutate, mrate, mscale) self.current_best = find_current_best(self.current_population, self.problem) ga = GeneticAlgorithm(population_size, vector_length, problem) . . Interact . The sliders, tap streams, and buttons for our dashboard. This is all using Holoviews and Panel. . Buttons . run_button begins a periodic update of our evolution process when the pn.widgets.Button is clicked. next_generation_button triggers just one generational update. new_pop_button triggers the creation of a new population. . Sliders and Layout . The rest are just pn.widgets.IntSlider or pn.widgets.FloatSlider sliders and markdown for the other bits and bobs. This is then positioned out using pn.Column, pn.Row and pn.Spacer from panel. . #collapse-show hv.extension(&#39;bokeh&#39;, logo=False) def tap_event(x,y): global target_x global target_y if x is not None: target_x, target_y = x,y return hv.Points((x,y,1)) target_x, target_y = 10, -10 tap = hv.streams.SingleTap(transient=True, x=target_x, y=target_y) tap_dmap = hv.DynamicMap(tap_event, streams=[tap]).opts(color=&#39;r&#39;, marker=&#39;^&#39;, size=10) mutate_checkbox = pn.widgets.Checkbox(name=&#39;Mutate&#39;, value=True) niters_slider = pn.widgets.IntSlider(name=&#39;Time Evolving (s)&#39;, start=0, end=50, value=5) mutation_rate_slider = pn.widgets.FloatSlider(name=&#39;Mutation Rate&#39;, start=0.0, end=1.0, value=0.3) mutation_scale_slider = pn.widgets.IntSlider(name=&#39;Mutation Scale&#39;, start=0, end=50, value=1) new_pop_button = pn.widgets.Button(name=&#39;New Population&#39;, width=50) def e(event): global ga population_size = 100 vector_length = 2 ga = GeneticAlgorithm(population_size, vector_length, problem) hv.streams.Stream.trigger(dmap.streams) new_pop_button.on_click(e) next_generation_button = pn.widgets.Button(name=&#39;Next Generation&#39;, width=50) def next_gen_event(event): hv.streams.Stream.trigger(dmap.streams) next_generation_button.on_click(next_gen_event) def update(): ga.next_generation(mutation_rate_slider.value, mutation_scale_slider.value, mutate_checkbox.value) return hv.Scatter(ga.current_population, label=&#39;Population&#39;).opts(color=&#39;b&#39;)*hv.Points((ga.current_best[0], ga.current_best[1],1), label=&#39;Current Fittest&#39;).opts(color=&#39;c&#39;, size=10) dmap = hv.DynamicMap(update, streams=[Stream.define(&#39;Next&#39;)()]) run_button = pn.widgets.Button(name=&#39; u25b6 Begin Evolving&#39;, width=50) def b(event): dmap.periodic(0.1, timeout=niters_slider.value, block=False) # Run the simulation for 60 seconds run_button.on_click(b) instructions = pn.pane.Markdown(&#39;&#39;&#39; # Genetic Algorithm Dashboard ## Instructions: 1. **Click on the plot to place the target.** 2. Click &#39; u25b6 Begin Evolution&#39; button to begin evolving for the time on the Time Evolving slider. 3. Experiment with the Mutation Rate (the probability of an individual in the next generation mutating) 4. Experiment with the Mutation Scale (the size of the mutation, tip: zoom out using the Wheel Zoom on the right of the plot). &#39;&#39;&#39;) dashboard = pn.Column(instructions, pn.Row((dmap*tap_dmap.relabel(&#39;Target&#39;)).opts(width=600, height=600), pn.Column(pn.Row(run_button, pn.Spacer(width=50), new_pop_button), next_generation_button, mutate_checkbox, niters_slider, mutation_rate_slider, mutation_scale_slider))) # dashboard # uncomment this to view the dashboard . . . Play with it yourself! . Here it is deploy on PyViz examples: https://genetic-algorithm.pyviz.demo.anaconda.com/GA. . You can also view and run all the code yourself from here. Thanks for reading. . Follow me on Twitter here for more stuff like this. .",
            "url": "https://www.scottcondron.com/jupyter/optimisation/visualisation/2020/07/20/interactive-genetic-algorithm-dashboard-from-scratch-in-python.html",
            "relUrl": "/jupyter/optimisation/visualisation/2020/07/20/interactive-genetic-algorithm-dashboard-from-scratch-in-python.html",
            "date": " • Jul 20, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "This blog post was written in a Jupyter Notebook",
            "content": "Why should I care? . I think it&#39;s kind of cool that you can write text beside snippets of code that actually run and automatically have the output of your code display alongside it. . A quick example: . Say I want to describe a function that plots a sine wave at different amplitudes. . First, I would define the function . import matplotlib.pyplot as plt import numpy as np def plot_sin(amplitude=1): &#39;&#39;&#39;Plot a sine wave of a given amplitude&#39;&#39;&#39; time = np.arange(0, 10, 0.1) y = np.sin(time) plt.plot(time, amplitude*y) plt.ylabel(&#39;Amplitude&#39;) plt.xlabel(&#39;Time (s)&#39;) plt.show() . Then, just after defining it, I could call it with different arguments and display the outputs alongside any text. . Sine wave with the default amplitude of 1 . plot_sin() . Sine wave with an amplitude of 20 . plot_sin(amplitude=20) . All of the above was written and ran within a Jupyter Notebook and automatically formatted for this blogpost. I didn&#39;t have to have some scripts lying around to create the images in the post. I didn&#39;t have to save, upload and link to the images. I didn&#39;t have to worry that the code examples wouldn&#39;t run. . You can also paste images as you would expect. . . How is that possible? . It&#39;s a mix and match of a few different tools. . Namely: . Jupyter Notebooks | fast-template | Github Pages | Jekyll | nbdev | . Jupyter Notebooks . I&#39;m imagining most people reading this will know what Jupyter Notebooks are. From their website: . The Jupyter Notebook is an open-source web application that allows you to create and share documents that contain live code, equations, visualizations and narrative text. . fast-template . The repo was first created from the fast-template repo from fast.ai&#39;s Jeremy Howard. This is a simplified way to generate a blog and host it using Github Pages. You can write your posts in Markdown Language and when you commit them to your repo, they will be converted to html for your blog using Jekyll. . nbdev . nbdev is a really powerful library which isn&#39;t being used to it&#39;s fullest potential here. It&#39;s a tool to create entire python libraries, a website hosting your documentation and way to automatically run tests... all using Jupyter Notebooks. . But for this project, it&#39;s being used to export output cells and any uploaded attachment from Jupyter Notebooks to markdown using nbdev_detach *.ipynb and nbdev_nb2md to convert notebooks to markdown. It&#39;s also being used to remove metadata from the notebooks during git commits, which helps reducing the change of merge conflicts. That last feature is probably overkill because I don&#39;t think I&#39;ll be doing a lot of merging. . Github Actions . Last but not least, Github Actions runs all of the above during each commit automatically! See here for the config. This is mostly taken from nbdev with a few things changed. . Thanks for reading . If you&#39;d like, you can find this blogs github repo here or follow me on Twitter here . A huge thanks to Jeremy Howard at fastai for making fast-template and nbdev which is doing all of the hard work to bring all these tools together! .",
            "url": "https://www.scottcondron.com/jupyter/blogging/visualisation/2020/01/20/this-blog-post-was-written-in-a-jupyter-notebooks.html",
            "relUrl": "/jupyter/blogging/visualisation/2020/01/20/this-blog-post-was-written-in-a-jupyter-notebooks.html",
            "date": " • Jan 20, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Begin creating Deep Learning models.",
            "content": "Following the advice of Julia Evans, I&#39;m going to write about things that I wish I knew a year ago. Machine Learning research sometimes feels like an activity reserved for the intellectually superior, while us mere mortals enjoy their trimmings when they publish and the open-source community implements it. . . You don&#39;t need a&#160;PhD . This myth was completely debunked for me when I took the fast.ai course, Practical Deep Learning for Coders, v3. So my first tip, do it. Also, this post by Rachel Thomas gives some great advice to those thinking about grad school. . If some of the stuff below seems like gibberish, fast.ai is a good place to go. . Tips for people wanting to begin creating / improving deep learning&#160;models. . Find a dataset that interests you. Here&#39;s a good post about where to find it. Try not to get analysis paralysis, just choose one. You&#39;re not married to the dataset you choose, but get to know it. . Here are plenty of resources to learn to visualize and analyze a dataset. . Use Google&#160;Colab . If you want free access to a GPU, here you go. If you want to know why or setting up a GPU is becoming frustrating. . Get 100% accuracy on one instance/batch of your&#160;data . Rather than wasting your time loading all of the data each time you want to check for bugs, create a tiny dataset with just one instance of your dataset and overfit it with a very simple model. . &#160;Get 100% accuracy on around 10% of your&#160;data . Once you can overfit your model on one instance, begin using more of your data and try to overfit it by adding more layers. Don&#39;t use any regularization for the moment (e.g., Dropout, L1/ L2 regularization), this is another sanity preserving tip so you know that your model is learning. . &#160;Add all of your training&#160;data . Once you add all of your data, if training is taking too long, leave it aside as an experiment and continue your work on the 10% of data. If you&#39;re overfitting when you add more layers and all of your data, here&#39;s five steps to reduce overfitting. . . And that&#39;s it for today, those tips are some of the valuable gems that I wish I found out sooner. If have any feedback, here&#39;s me on Twitter. . Thanks for reading .",
            "url": "https://www.scottcondron.com/deep%20learning/ai/2020/01/17/begin-creating-dl-models.html",
            "relUrl": "/deep%20learning/ai/2020/01/17/begin-creating-dl-models.html",
            "date": " • Jan 17, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "I’m from Dublin, Ireland 🇮🇪 and living in Edinburgh, Scotland 🏴󠁧󠁢󠁳󠁣󠁴󠁿 . I’m currently interested in Deep Learning with Audio, Python software development and bits and bobs from lots of other areas. . I was working as a web/mobile software developer for a few years and then went back to university to do an MSc in AI in Heriot Watt University, Edinburgh. . I’m now working as a Research Engineer in Speech Graphics . You can follow me on Twitter here. .",
          "url": "https://www.scottcondron.com/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://www.scottcondron.com/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}